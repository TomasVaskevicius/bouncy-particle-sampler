#pragma once

#include <functional>
#include <vector>

#include "analysis/output_processors/sequential_processor_base.h"

namespace pdmp {
namespace analysis {

/**
 * Online implementation of Autocorrelation function calculation.
 */
template<class Pdmp, class State, class Flow>
class AutocorrelationCalculator : public SequentialProcessorBase<Pdmp, State> {

 public:

  using RealType = typename State::RealType;

  /**
   * A helper data structure for representing time windows of data.
   * This window will slide through the trajectory being generated by the
   * observed pdmp.
   */
  class TimeWindow {

   public:

    // Adds a given segment to the time window
    // (updates integrandAtPoints vector).
    void addSegment(
      const IterationResult<State>& start,
      const IterationResult<State>& end,
      std::function<RealType(State)>& integrand);

    // The time outer class will pass its data members, which will be
    // updated using the data in integrandAtPoints member.
    // The integrandAtPoints member will be cleaned up (leaving only the
    // tail of the vector, which will be used in subsequent calculations).
    void updateCovarianceEstimatesAndCleanUpData(
      const RealType& mean,
      std::vector<RealType>& covarianceEstimates,
      int& numberOfPointsUsedForCovarianceEstimates);

    std::vector<RealType> getIntegrandAtPoints() const;

   private:

    // A vector with integrand estimates at equally spaced points.
    std::vector<RealType> integrandAtPoints_;

    // Segment lengths in general will not be divisible by the step size.
    // Unused end of last segment is used a beginning of a new segment.
    float paddingSize_{0.0f};
  };

  AutocorrelationCalculator(std::function<RealType(State)> integrand);

  AutocorrelationCalculator(
    std::function<RealType(State)> integrand,
    const RealType& realMean,
    const RealType& realVariance);

  /**
   * Returns the autocorrelations vector.
   */
  auto getAutocorrelationsVector();

  /**
   * Returns the max lag.
   */
  int getMaxLag() const;

  /**
   * Returns the number of steps we make in one unit length size when we
   * discretisize the path of our process.
   */
  int getLagStepsPerUnitLength() const;

  /**
   * Returns the mean estimate obtained by numerical integration.
   * If the real mean was provided in the constructor, the real mean is
   * returned.
   */
  auto estimateMean() const;

  /**
   * Return the variance estimate obtained by numerical integration.
   * If the real variance was provided in the constructor, the real variance is
   * returned.
   */
  auto estimateVariance() const;

 protected:

  virtual void processTwoSequentialResults(
    const IterationResult<State>& first,
    const IterationResult<State>& second) override final;

 private:

  // Updates the member variables for mean and variance calculations.
  void updateMeanStatistics(
    const IterationResult<State>& first,
    const IterationResult<State>& second);

  // Data members for estimating mean and variance.
  RealType totalTrajectoryLength_{0.0f};
  RealType currentPathIntegral_{0.0f};
  RealType currentPathIntegralOfSquaredFunction_{0.0f};

  std::function<RealType(State)> integrand_;
  TimeWindow timeWindow_;

  // Stored calculations for autocorrelation estimation.
  std::vector<RealType> covarianceEstimates_;
  int numberOfPointsUsedForCovarianceEstimates_{0};

  // Data members for the case of having the real mean and real variance.
  RealType realMean_;
  RealType realVariance_;
  bool hasRealMeanAndVariance_;

};

}
}

#include "autocorrelation_calculator.tcc"
